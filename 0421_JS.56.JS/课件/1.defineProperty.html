<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
	<title>珠峰培训 - 微信：18310612838</title>
	<!-- IMPORT CSS -->
</head>

<body>
	<div id="app">
		<input type="text" id="inpBox">
		<span id='spanText'></span>
	</div>
	<!-- IMPORT JS -->
	<script src="../node_modules/vue/dist/vue.js"></script>
	<script>
		//=>响应式数据
		let data = {
			msg: '珠峰培训'
		};
		let tempData = {
			msg: data.msg
		};
		Object.defineProperty(data, 'msg', {
			set(value) {
				tempData.msg = value;
				render();
			}
		});

		//=>渲染视图
		function render() {
			inpBox.value = tempData.msg;
			spanText.innerHTML = tempData.msg;
		}
		render();

		//=>视图数据更改的监听
		inpBox.addEventListener('input', function () {
			data.msg = this.value;
		});



		/* let vm = new Vue({
			el: '#app',
			data: {
				msg: '珠峰培训'
			}
		}); */
	</script>

	<script>
		/* let vm = new Vue({
			el: '#app',
			data: {
				//=>响应式数据（基于Object.defineProperty进行处理过的 GETTER/SETTER）
				msg: '珠峰培训',
				//Object.defineProperty(data,'obj',{get/set})
				obj: {
					//=>vue内置的observer/defineRective函数，会帮我们把所有在DATA中初始化的属性都GETTER/SETTER了（递归处理）
					// name: ''
				},
				//ARR本身被GETTER/SETTER了，但是里面的每一项都没有被处理，所以基于arr[index]=xxx修改值不能通知视图重新渲染 =>vue对于数组是这样处理的：把数组中的一些内置方法进行重写push/pop/unshift/shift/splice/reverse/sort，当我们调取这些方法的时候，vue会帮我们刷新视图
				arr: [100]
			},
			created() {
				this.year = 10;
			},
			mounted() {
				setTimeout(() => {
					// this.msg = '珠峰培训就业课';
					// this.year = 11;

					// this.obj = {
					// 	name: '周啸天'
					// };  //=>这样才是修改OBJ的值，触发DATA:OBJ属性的SETTER

					// this.obj.name = '周啸天';
					// $set不仅仅是用来修改数据的，而且可以把被修改的属性基于defineProperty进行GETTER/SETTER
					this.$set(this.obj, 'name', '周啸天');
				}, 1000);
				setTimeout(() => {
					this.obj.name = '呵呵呵';
				}, 2000);
			}
		}) */
	</script>

	<script>
		/* //Object.defineProperty：对一个对象中某个属性的定义（处理）
		let obj = {
			name: '珠峰培训',
			age: 10
		};
		//=>设置属性的GETTER、SETTER：我们可以在GETTER、SETTER中监听当前属性设置和获取的时候干什么 =>这也是VUE 2.0响应式数据（双向数据绑定）实现的原理，VUE 3.0采用的是PROXY
		Object.defineProperty(obj, 'name', {
			get() {
				console.log('GETTER');
				return 'HELLO WORLD';
			},
			set(value) {
				console.log('SETTER', value);
			}
		});
		// console.log(obj.name);
		obj.name = '哈哈哈~~'; */

		/* Object.defineProperty(obj, 'name', {
			value: '珠峰培训',
			//=>是否允许当前的属性被删除
			configurable: true,
			//=>是否为可枚举的属性
			enumerable: true,
			//=>是否允许当前属性被修改
			writable: true
		});
		// delete obj.age;
		// delete obj.name;
		// for (let key in obj) {
		// 	console.log(key);
		// }
		// obj.name = '周啸天';
		console.log(obj); */
	</script>
</body>

</html>