<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
        新的数据结构 Set Map
        Set  : set实例里的成员都是唯一的
        size===length  :实例成员总数
        add() 增加
        delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
        has(value)：返回一个布尔值，表示该值是否为Set的成员。
        clear()：清除所有成员，没有返回值。
        keys()：返回键名的遍历器
        values()：返回键值的遍历器
        entries()：返回键值对的遍历器
        forEach()：使用回调函数遍历每个成员


        Symbol(Symbol.toStringTag): "Set"
        */
        /* let res = new Set([1, 2, 3, 4, 5]);

        let ary = [1, 2, 3, 1, 2, 3, 1, 2, 3];
        ary = [...new Set(ary)];//展开set的实例
        // 扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。

        res.forEach((item, index) => {
            console.log(item, index);//11 22 33 44 55
        }) */


        /* 
        Map
        */



        /* 
        Iterator 接口   返回值
        只要自己数据的原型上有Symbol(Symbol.iterator): ƒ values()这个属性 可以使用for of 就说明是可以遍历的
        for of 是循环接口的返回值
        */
        let ary = [1, 2, 3, new Set([1, 2]), new Map()];
        let ss = new Set([1, 2, 3])
        for (let key of ss) { console.log(key) }//1,2,3
        for (let key of [5, 6, 7]) { console.log(key) }//5,6,7



        /* 过程为for of去做
         var it = makeIterator(['a', 'b']);
             //for of去调用next方法执行，每执行一次就会返回一个对象，对象里的value就是当前得到的值，done就是是否把值遍历结束
             it.next() // { value: "a", done: false }
             it.next() // { value: "b", done: false }
             it.next() // { value: undefined, done: true }
 
             function makeIterator(array) {
                 var nextIndex = 0;
                 return {
                     next: function () {
                         return nextIndex < array.length ?
                             { value: array[nextIndex++], done: false } :
                             { value: undefined, done: true };
                     }
                 };
             } */
        Object.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]
        let obj = {};
        for (let key of obj) {

        }


        /* 
        Generator 生成器函数
        在创建函数的时候，在function之后加上一个*，那当前的函数就变成了generator函数了
        让generator执行，并不会使其内部代码马上执行，而且会返回一个生成器。
        */
        /* function* fn() {
            console.log('第一步');
            yield 1
            console.log('第二步');
            yield 2
            console.log('第三步');
            yield 3

        }
        let res = fn();
        console.log(res.next()); //第一步 {value: 1, done: false}
        console.log(res.next()); //第二步 {value: 2, done: false}
        console.log(res.next()); //第三步 {value: 3, done: false}
        console.log(res.next()); //{value: undefined, done: true} */

        function request() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('ok');
                }, 3000)
            })
        }
        /*         function* fn() {
                    console.log('发送第一次请求');
                    let res = yield request();
                    console.log('拿到第一次请求返回的结果', res);
        
        
                    console.log('发送第二次请求');
                    let res1 = yield request();
                    console.log('拿到第二次请求返回的结果', res1);
        
        
                    console.log('发送第三次请求');
                    let res2 = yield request();
                    console.log('拿到第三次请求返回的结果', res2);
        
                }
                let res = fn();
                // console.log(res.next('1'));
                //  console.log(res.next('2'));
                //  console.log(res.next('3'));
                //  console.log(res.next('4')); 
                res.next('ok').value.then((result) => {
                    res.next(result).value.then((result) => {
                        res.next(result).value.then((result) => {
                            res.next(result).value.then((result) => {

                        })
                        })
                    })
                });
         */
// 实现ajax 串行
        async function fn() {
            console.log('发送第一次请求');
            let res = await request();
            console.log('拿到第一次请求返回的结果', res);


            console.log('发送第二次请求');
            let res1 = await request();
            console.log('拿到第二次请求返回的结果', res1);


            console.log('发送第三次请求');
            let res2 = await request();
            console.log('拿到第三次请求返回的结果', res2);

        }
        let res = fn();
    </script>
</body>

</html>