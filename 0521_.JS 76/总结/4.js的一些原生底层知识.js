
// dom事件绑定：
//   - dom2级是通过原型链找到EventTarget上的addEventListeners上的方法并且让其执行(并且采用的是事件池机制)
//   - dom2级可以绑定所有的事件，但是dom0级有一些事件时不可以绑定的，比如window.onDomContentLoaded是不行的，但是使用dom2级就可以绑上


// js数据类型以及typeof的使用方法
//   基本数据类型
//     number
//     string
//     boolean
//     null
//     undefined
//     symbol 唯一值
//     bigint 大数
//   引用数据类型
//     object
//     function(可执行对象)
//----------------------------------------------

/* 
bigint
js中是有最大和最小数字的界限的,超过限制计算就不准确了
Number.MAX_SAFE_INTEGER
Number.MIN_SAFE_INTEGER
  如果服务器返回的数字超过了最大的安全数字，
    - 如果只需要展示，可以把数字变为字符串进行展示
    - 如果需要进行计算，我们就需要bigint进行处理了
        let n = 9007199254740992n;
        n = n+1n 相当于在原来的基础之上加1

 */

/* 
  数据类型检测typeof
  - typeof null -->'object'
  - typeof检测对象数据类型，除了可执行对象(函数：能够调用call方法的函数--普通函数、箭头函数、构造函数、生成器函数)检测出来的是 'function'，其余的都是 'object'
  - typeof的底层机制：
    + 所有数据类型在计算机中都是以2进制值进行存储的
        整数 1  浮点：010  字符串100  布尔110  对象000  undefined-3^30  null000000
    + typeof的底层机制就是判断这些二进制值，如果是以000开始的就是对象(排除可执行的对象)，那返回的都是 'object' 但是null开头也是000，所以null返回的也是 'object'
    + 稳定性和性能很好，而且使用起来也简单，
*/

//---------------------------------------------------------------------
/* 数据类型转换规则
  - 把其他数据类型转换为字符串，如果是基本值就是直接加字符串，但是bigint会去掉n；但是要防止字符串的拼接
    - {} + 10 -->10 他会认为左侧是一个代码块，不参与运算
    - 10 +{} -->'10[Object object]' 字符串拼接
    - 对象相加的时候，有的时候不是字符串拼接
            + 先去调用Symbol.toPrimitive属性值，如果没有这个属性
            + 在去调用valueOf获取原始值，如果没有原始值
            + 在去调用toString 方法转换为字符串 (如果想转数字还会调用Number方法) 
*/
/* 
parseInt
  + parseInt执行的时候，先把传递的值转化为字符串，然后在开始从左往右开始查找，直到遇见非有效数字为止，那找到的哟偶小数字返回出去
  + parseInt(string,radix) radix是进制，有效取值范围是2-36之间，如果不传递是默认是10进制，【但是如果字符串是以0x开始的，那默认是16进制】，如果写0，那跟不写是一样的
  + 把string进行转进制【从左往右找到符合这个进制的字符，把找到的字符转换为数字10机制】
  + radix不在2-36之间就是NaN

  进制：
    2进制 0-1
    8进制 0-7
    10进制 0-9
    16进制 0-9 A-F
  转换：
    把其他进制转换为10进制
    let str = '12345.23'  把8进制转换为10进制 (有小数点是负数次幂算)
    3*8^-2 + 2*8^-1    5*8^0 + 4*8^1 + 3*8^2 + 2*8^3 + 1*8^4 -->十进制的值

    parseInt(0x0BFAC) --->把'0BFAC'16进制的换换为10进制的
    以0开始的数字浏览器会把他以8进制转换为10进制  0123-->83

  let arr = [27.2,0,'0013','14px',123];
  arr = arr.map(parseInt);
  console.log(arr)

  parseInt(27.2,0)  把'27.2'当做10进制转换为10(0和10是一样的)进制 -->27
  parseInt(0,1)     1不在2-36之间-->NaN
  parseInt('0013',2)  -->把'001当做二进制转化为10进制' 1*2^0 + 0*2^1 + 0*2^2-->1
  parseInt('14px',3) -->  把'1'当做3进制转化为10进制 1*3^0 -->1
  parseInt(123,4)   -->把 '123'当做4进制转化为10进制 3*4^0 + 2*4^1 + 1*4^2-->3+8+ 16-->27

  所以最后是 [27,NaN,1,1,27]
*/

/* 
 函数的惰性思想
 基于函数重构的方式去改变函数体
 当有很多业务逻辑的时候，第一次执行一次就知道要干啥了，那以后我在走一遍这个逻辑其实就是浪费了，所以在第一次走完之后我就把函数给改了，以后再走的时候直接走改完之后的函数了
*/

/* 
闭包：利用闭包的保存作用，我们可以把一些信息预先的存储起来【进行预处理】，供其下级的上下文中使用，我们把这种预先处理【存储的机制称之为函数柯理化】

回答闭包的几个方面：
  1.基本概念 函数执行形成一个不销毁的作用域，就会形成闭包，他会保存当前的私有上下文中的变量不被销毁和干扰
  2.进阶：单利模式、柯理化函数。。。
  3.对上边的解释：单例模式是怎么回事(各种源码jQuery...)、柯理化函数的应用(防抖节流、bind。。。)
*/


//-------------------
/*
var a = [1,2,3];
a.toString = a.shift;
-------------------
var a = {
  i:0,
  [Symbol.toPrimitive](){
    // 比较的时候涉及数据类型的转换，会把对象转换，就会默认调用当前的方法，现在事吧这个方法重写
    return ++this.i
  }
}
-----------------------------
var a = 0;
Object.defineProperty(window,'a',{
  get(){
    return ++a
  }
});
if(a==1 && a==2 && a==3){
  console.log('ok');
}
 */

/* 
js中的书写和显示的数值是10进制的，但是存储到计算机底层以及运算的时候，都是先转换为2进制，在进行运算和存储的

0.1+0.2 !== 0.3
把0.1转换为2进制-->
 0.1*2 = 0.2 -->0
 0.2*2 = 0.4 -->0
 0.4*2 = 0.8 -->0
 0.8*2 = 1.6 -->1
 0.6*2 = 1.2 -->1
 ... 所以最后的结果为 00011....这个结果是经过四舍五入的

因为0.1和0.2本身存储的二进制事经过省略的，最后相加的结果也会存在精度差
这是计算机的底层缺陷

*/

/* 
2.基于instanceof本意事用来检测当前实例是否属于某个类，并不是专业的进行数据类型检测的，只不过我们事基于他的特点，临时的进行数据类型的检测，但是准确度不好
  原理：实例对象obj  instanceof 构造函数Ctor
  1.检测构造函数是否拥有Symbol.hasInstance这个属性，如果有这个属性，就让Ctor[Symbol.hasInstance](obj) -->他返回的就是true或者false
  2.检测当前实例的原型来链上是否会出现当前的这个构造函数，如果出现就是true，否则就是false
  3.原始值类型是不能基于instanceof进行检测的，原始值不具备原型链的
*/
/* 
3.constructor
4.Object.prototype.toString.call() // 返回值是 '[object 实例[Symbol.toStringTag]]'  如果没有这个属性，那就是当前实例所属的构造函数
但是不能够检测自定义的类

class Fn {
  [Symbol.stringTag] = 'Fn' // 可以给自定义的类加上和这个属性
}
*/