// npm 可以用命令的方式  yarn 与npm一样 下载插件  nrm控制从哪里的网络下载
//npm i less -g  把less放到c盘     lessc index.less index.css 在命令行手动转译
// 命令性的工具都是放在全局


/* 
浏览器的前后端交互
https://credit.baidu.com:8080/index.html  //https 协议：域名
    协议部分：传输协议就是能够把客户端和服务端通讯的信息进行传递的工具
    - http：超文本传输协议，除了传递文本还可以传递媒体资源文件以及XML格式数据
    - https：更加安全的http，一般涉及支付的网站都要采用https协议（s：ssl加密传输）
    - ftp：文件传输协议（一般用于把本地资源上传到服务器，就是把你的前端资源代码上传到服务器的时候用到的一种传输协议）「画图FTP」


    - 域名(每一个服务器都有自己的唯一的IP地址，每一个域名都可以和ip进行绑定)
    - 域名：（www.baidu.com）
    - 顶级域名 baidu.com（以后花钱买域名的时候，只需要把顶级域名买下就可以，去万网买）
    - 一级域名 credit.baidu.com
    - 二级域名know.credit.baidu.com
    - 三级域名cqw.know.credit.baidu.com
    - .com 国际域名（面向国际化）
    - .cn   中国域名
    - .com.cn
    - .edu  教育
    - .gov  政府类
    - .io  博客
    - .org   官方组织
    - .net  系统类
    每个服务器都有自己的唯一的IP   每一个域名都可以和IP进行绑定
    
    - 端口号：（：80）0-65535 用端口号来区分同一台服务器上不同的项目，一个端口下可以部署一个项目
    - http：默认端口号80
    - https：默认端口号是 443
    - ftp默认端口号是21
    - 如果项目采用的就是默认端口号，那我们在写地址的时候可以不加端口号，浏览器在发送请求的时候会帮我们加上

    服务器是主机 很大  可以存储 65536个项目  把服务器分成一个个小房间 8080就是房间号   0-65535随意写 端口号
    不写默认端口号 使用工具上传 在工具可以设置默认文件
https://credit.baidu.com/bkrcredit/cardDetail?cardCode=5103&sid=detailhot%3A1002&path=home&module=home_hotcards&traceId=cs640242600#index
    

    - 请求资源路径名称：（bkrcredit/cardDetail） 后端根据不同的处理数据请求
    - 先去画图（服务器接收到请求后要做的事）
    - 默认的路径或者名称（不指定资源名，服务器会找默认的资源，一般资源的默认资源名称是 default.html、index.html...当然这些咱们都可以在服务器端进行配置)
    - bkrcredit/cardDetail  数据请求
    - .html  .js  .css  html文件js文件 css文件  静态资源文件
    /index.html 可以省略


    hash只有前端用  路由当作判断依据
    客户端是前端   服务端是后端
1、解析URL
2、发送URL请求
3、DNS域名解析请求
4、和服务器建立TCP连接 （三次握手/客户端：我要与你建立连接，可以的话你告诉我。服务端：可以连接 客户端：好的那我建立连接了/开启双向通道 ）
5、把客户端信息传递给服务器（发送Http请求）//request2-5是请求阶段

6、response响应阶段
7、 服务器收到并处理请求（HTTP响应的内容）
8、和服务器断开TCP连接（四次挥手/客户端主动关闭，服务器被动关闭。我数据发完了，你接收完告诉我，我已经把你发的数据接收完毕了，你可以关闭了。从左到右（从客户端到服务端）的那条关闭。服务端说我把数据都传给你了，你收完了告诉我，客户端说我收完了可以关闭了。从右到左（服务端到客户端）的也关闭了）
9、 客户端渲染服务器返回的内容
DNS（DNS域名解析服务器）据说根（主）服务器在美国（日本） 网址到IP地址的转换

服务器接收到请求后要做的事：浏览器做的
1、 根据端口号找到对应的项目
2、 根据请求的资源路径名称找到对应的文件
3、 读取资源文件中的内容
4、 把内容进行返回

https://m.360buyimg.com/mobilecms/s120x120_jfs/t1/129215/21/5978/3618/5efbf344Ebec23ae8/59712d986b10bb0a.png.webp

  <img src="" alt="//img10.360buyimg.com">
  <img src="" alt="//img20.360buyimg.com">

  <img src="" alt="https://www.baidu.com/image1.jpg">
  <img src="" alt="https://www.baidu.com/image2.jpg">
  <img src="" alt="//img10.360buyimg.com">

    DNS服务器域名解析
      DNS服务器：域名解析服务器，在服务器上存储着 域名<=>服务器外网的IP 的相关记录
      当我们发送请求的时候做DNS解析其实就是根据域名在DNS服务器上查找到对应的外网IP

    前端性能优化：
      - DNS缓存(一般浏览器会在第一次解析之后，默认建立缓存，时间很短，大概一分钟左右)
      - 减少DNS解析次数(一个网站中我们需要发送的请求域名和服务器尽可能减少)
      - 做DNS预获取dns-prefetch(在页面开始加载的时候，就把当前页面中需要访问的其他域名信息进行提前的DNS解析，以后加载到具体内时候就可以不用域名解析了)



       建立TCP连接(客户端和服务器之间的传输通道就打通了)和HTTP报文

    三次握手

    1、浏览器需要发送一个SYN码给服务器，告诉服务器我要和你建立连接
    2、服务器接收到SYn码之后，服务器在给客户端发送一个SYN+ACK码，告诉客户端咱们可以建立连接
    3、客户端收到ACK码之后验证是否正确，如果正确，在向服务端发送一个ACK码，告诉服务端好的，咱们马上建连接吧

    到此连接通道已经创建好了


    HTTP报文
    - 请求报文：所有经过传输协议，客户端发送给服务端的内容，都是请求报文
        + 请求头
        + 请求体
    - 响应报文: 所有经过传输协议，服务端响应给客户端内容，都是响应报文
        + HTTP状态码
        + 响应头
        + 响应体

    HTTP报文 ： 请求报文 + 响应报文

      XHR请求的ajax
      get没有请求主体，建立连接的时候就给他了
      xhr.send('xxx')这里面才是请求主体，你真正想给后台发送的参数  post才有请求主体


      响应头 content-type：txt/html 客户端按照这种格式接收 提前做好渲染html的准备



      HTTP状态码，他代表了当前请求的状态
    - 200: 成功
    - 201：一般应用于告诉服务器创建一个新的文件，最后服务器的返回的状态码就是201
    - 204：若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码

    - 301：永久重定向 一般用于域名的迁移
    - 302：临时转移(临时重定向) 服务器的负载均衡 ，现在这个功能是返回307了(以后307代表临时转移的意思)

    - 304：设置HTTP的协商缓存

    - 400 ：给服务器传递的参数是错误的
    - 401: 没有权限访问
    - 404：请求地址错误

    - 500: 服务器的未知错误
    - 503：服务器超负荷



    四次挥手：

    1、当客户端无数据要传输了，会发送FIN码告诉服务器，我发送完毕了；
    2、当服务端接收完毕后，告诉客户端ACK码，告诉客户端你可以把数据通道关闭了；
    3、当服务器发送完毕之后，也会发送FIN码，告诉浏览器，数据发送完毕；
    4、当客户端接收完毕 之后，同样发送ACK码，告诉服务器，数据接收完毕，你可以关闭；
    三次握手和四次挥手的好处：确保数据的安全和完整


    默认隐藏index.html 


    


     浏览器的渲染
        在渲染的时候遇到link/img/video/audio等都是异步去加载信息(浏览器会分配一个新的线程只执行当前的任务，主线程继续往下走)，但是遇到script、@import，必须是同步加载信息了，当信息加载完成之后，主线程才会继续往下走

    DOM的回流和重绘
    重绘：元素的样式改变，但是元素的大小，位置，宽高不变
    回流：元素的大小或者位置发生的变化，会触发（render tree）重新布局，导页面重新的布局和渲染
    注意的是：回流一定会引发重绘，但是重绘不会引发回流

    前端性能优化的几个点：
    1、放弃传统的操作DOM的时代，基于react、vue去写你的项目，(特点是数据影响视图的模式，框架内部操作的是虚拟的DOM，还会进行DOM-diff的对比)

    2、DOM操作的读写分离
    现代版的浏览器有一个"渲染队列"的机制，如果发现某一行要修改元素的样式，不会立即进行渲染，他要看看下一行是否还要进行元素样式的修改，如果是，那就把上一次的修改样式放到渲染队列里，这个过程一致持续到不是修改样式的操作为止，整体进行一次渲染引发一次回流，

    js中的13个盒子模型和getComputedStyle和style都会引发渲染队列的刷新

    box.style.width = 100 +'px';
    box.style.height = 100 +'px';
    box.style.padding = '10px';

    console.log(box.style.width);

    -------------------------------------
    一开始的width是80px
    box.style.width = 100 +'px';
    console.log(box.clientHeight);
    box.style.height = 100 +'px';
    console.log(box.style.width); // 100px
    box.style.padding = '10px';

     // 3、样式的集中改变
    // box.style.cssText = 'width:100px;height:100px;padding:10px'
    //  或者动态增加类名
    // 能拿css完成的就不要拿js去写

     // 5、文档碎片 cerateDocumentFragment 模板字符串

      box.style.width = box.offsetWidth + 1 + 'px';
    box.style.height = box.offsetHeight + 1 + 'px';
    // 此处渲染两次
    // ---------------------------------

    // 此处渲染一次 （缓存布局）
    let w = box.offsetWidth;
    let h = box.offsetHeight;

    box.style.width = w + 1+'px';
    box.style.height = h + 1 + 'px';
*/

